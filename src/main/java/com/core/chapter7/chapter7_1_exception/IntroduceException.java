package com.core.chapter7.chapter7_1_exception;

/**
 * 如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据丢失
 * 用户有可能不在使用这个程序，为了避免此类事情发生，至少应该做到以下几点
 * 1.向用户报告错误
 * 2.保存所有的工作结果
 * 3.允许用户以妥善形式退出程序
 * 对于异常情况，如可能造成程序崩溃的错误输入，Java使用一种称为异常处理的错误捕获机制处理
 * 一。处理错误：
 * Java程序运行期间出现了错误，程序应该：
 * 1.返回到一种安全状态，并能够让用户执行一些其他的命令
 * 2.或者允许用户保存所有的操作并以一种妥善的方式终止程序
 * 要做到这些并不是一件容易事
 * 因为检测错误条件的代码通常离那些能够让程序恢复正常状态的代码很远
 * 异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器
 * 为了在程序中能够处理异常情况，就必须研究程序中可能会出现的错误和问题,以及哪类问题需要处理
 * 1.用户输入错误
 * 2.设备错误
 * 3.物理限制
 * 4.代码错误
 * 对于方法中的错误，传统的做法通常是返回一个特殊错误码，由调用方法分析。
 * 在Java中如果某个方法不能够采用正常的途径完成他的任务，就可以通过另外一个途径退出方法。在这种情况下，方法
 * 并不返回任何值，而是抛出throw一个封装了错误信息的对象。这个方法会立刻退出，并不返回任何值。
 * 调用这个方法的代码也将无法执行，取而代之的是，异常处理机制开始搜索能够处理这种异常情况的异常处理器（exception handle）
 * 1.异常分类
 * 异常对象都是派生于Throwable类的一个实例，Exception和 Error都是继承于Throwable类，IOException和RuntimeException都继承于Exception类
 * Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。发生这种错误，除了通报给用户，让程序安全的终止，也无能为力
 * Exception层次结构
 * Exception层次结构分解为两个分支，一个分支派生于RunTimeException ，另一个分支包含其他异常，划分两个分支的规则是：
 * 1.由程序错误导致的异常属于RunTimeException
 * 2.程序本身没有问题但是由于像I/O错误这类问题的异常属于其它异常
 * 派生于RunTimeException的异常包含下面几种情况
 * 1.错误的类型转换
 * 2.数组访问越界
 * 3.访问null指针
 * 等等
 * 不是派生于RunTimeException
 * 1.试图在文件尾部后面读取数据
 * 2.试图打开一个不存在的文件
 * 3.试图根据给定的字符串查找Class对象，而这个字符串表示的类不存在
 * 等等
 *
 * 如果出现RunTimeException，那么就一定是你的问题，是一条相当有道理的规则，应当检测数组下标是否越界
 * 来避免ArrayIndexOfBoundsException异常，应该通过在使用变量之前检测是否为null来杜绝NullPointerException
 * 文件是否存在取决于环境，不取决于你的代码。
 * Java语言规范将派生于Error类和RuntimeException类的所有异常称为非受检查的异常（unchecked），所有其他的异常称为受检查的异常（checked）
 * 编译器将会核查是否为受检查异常提供了异常处理器
 * 2.声明受查异常
 * 如果遇到了无法处理的情况，Java可以抛出一个异常。这个道理很简单，一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器可能发生什么错误。
 * 例如，一段读取文件的代码有可能读取的文件不存在，或者内容为空，因此试图处理文件信息的代码就需要通知编译器可能会发生IOException
 * 方法应该在首部声明可能会抛出的异常，例：
 * public FileInputStream(String name)throws FileNotFoundException
 * 这个声明表示构造函数将根据name产生一个FileInputStream对象，但也有可能抛出一个FileNotFoundException
 * 如果发生了这种糟糕情况，构造器将不会初始化一个新的FileInputStream对象，而是抛出一个FileNotFoundException类对象，
 * 如果真的抛出了这样一个异常对象，运行时系统将会搜索异常处理器，以便知道如何处理FileNotFoundException对象
 * 遇到下面4种情况时应该抛出异常
 * 1：调用一个抛出受检查异常的方法，例如FileInputStream构造器
 * 2：运行过程中发现错误，并且利于throw语句抛出一个受查异常
 * 3：程序发生错误会抛出非受查异常
 * 4：Java虚拟机和运行时库出现的内部错误
 * 如果出现前两种情况，则必须告诉调用这个方法的程序员有可能抛出异常。因为任何一个抛出异常的方法都有可能是一个死亡陷阱，
 * 如果没有处理器捕获这个异常，当前线程就会结束。
 * 对于那些可能被他人使用的Java方法，应该根据Java异常规范（exception specification）,在方法的首部声明可能会抛出的异常
 * class MyAnimation{
 *     ...
 *     public void loadImage(String s)throws IOException{
 *
 *     }
 * }
 * 如果一个方法可能会抛出多个受查异常类型，必须在方法首部列出所有受查异常类，每个类之间用逗号分隔
 * class MyAnimation{
 *     ....
 *     public void loadImage(String s) throws FileNotFoundException,EOFException{
 *
 *     }
 * }
 * 但是不需要声明Java的内部错误，即从Error继承的错误。任何代码都具有抛出异常的潜能，我们对其没有控制能力
 * 也不应该声明从RunTimeException继承的那些非受查异常，运行时错误完全在我们的控制之下，如果特别关注数组下标越界，
 * 就应该将更多的时间花费在修正程序上，而不是说明这些错误发生的可能性上。
 * 总之一个方法必须声明所有可能会抛出的受检查异常，而非受检查异常，要么不可控制（ERROR），要么就应该避免发生（RunTimeException）
 * 除了声明异常，还可以捕获异常，这样会使异常不被抛到方法之外，也不需要throws规范
 *
 * 如何决定一个异常是被捕获，还是被抛出让其它处理器处理
 * 3.如何抛出异常
 * Created by yuanqingjing on 2019/12/3
 */
public class IntroduceException {

}
